{"meta":{"title":"Seventysix's blog","subtitle":"","description":"","author":"Seventysix","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-01-23T11:09:27.899Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-01-23T11:09:27.957Z","updated":"2023-01-23T08:35:03.120Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-01-23T11:09:27.929Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-01-24T10:15:35.380Z","updated":"2023-01-24T10:15:35.380Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系方式 邮 箱：beason76@foxmail.com 工作经历 网易（上海）网络科技有限公司 2020.7~至今 高级测试开发工程师 负责QA安全中台安全评审、工具研发、安全测试等安全相关工作； 参与过上海部分游戏项目自动化测试、CI/CD的开展； 参与过上海部分游戏项目测试工作开展的技术支持； 参与过公共工具的研发维护。 教育经历 上海大学 2018~2020 软件工程-硕士 宁波大学 2014~2018 信息管理与信息系统-本科 个人介绍 一个平平无奇的上班族罢了，喜欢看番、打游戏、研究感兴趣的技术"},{"title":"分类","date":"2023-01-23T11:09:27.943Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-01-23T11:09:27.986Z","updated":"2023-01-23T08:35:03.120Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-01-23T11:09:27.971Z","updated":"2023-01-23T08:35:03.120Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask建站自用标配","slug":"Flask建站自用标配","date":"2023-01-25T06:54:31.000Z","updated":"2023-01-25T06:54:31.000Z","comments":true,"path":"2023/01/25/Flask建站自用标配/","link":"","permalink":"http://example.com/2023/01/25/Flask%E5%BB%BA%E7%AB%99%E8%87%AA%E7%94%A8%E6%A0%87%E9%85%8D/","excerpt":"","text":"简介 一套自己在部署Python开发的后端服务时常用的架构，简单做个记录。 一图流 入口 请求直接打到nginx。虽说直接用nginx作为入口，一旦nginx挂了整个服务就挂了。但由于目前参与部署的服务大多是公司、部门内部使用的服务，或者是自己搭着玩的web站点，机器资源有限（一般就只有一台），因此单点挂了就挂了。 如果是有个集群的情况下，可以通过Keepalived来应对nginx单点故障的问题。 在我目前的场景中，nginx主要起到： 处理静态请求展示前端页面； 内部域名映射； 多个服务的统一入口管理。 应用容器 Flask、Django开发的应用直接用命令行跑起来，其他人当然也是可以调用的。但假如你这个服务使用的人多了起来，Flask等自带的wsgi性能就不那么好了。uWSGI、Gunicorn这类wsgi server可以提供更好的并发性能支持。 《WSGI 服务器性能分析》中对比了比较出名的几款wsgi工具的性能，这里我常用的是Gunicorn。 Web框架 个人更喜欢Flask，相对Django而言更精简。不过这部分用什么框架还是看实际场景和需求，还有开发人员的熟练程度吧。 监控管理 一方面Gunicorn重启关闭麻烦，另一方面我们又希望如果服务进程因为内部错误等原因挂了，还能够自己重新启动，不妨碍继续使用。因此supervisor的引入是非常有必要的。 supervisor可以起到以下几个作用： 简单配置之后可以非常方便的进行Gunicorn进程的启动、重启、关闭； 可以查看Gunicorn的执行状态； 可以配置挂掉的进程自动重启。 CI/CD 这部分其实就是自动更新部署的内容，最开始的时候是直接写个shell脚本去进行服务端项目的更新、重启，后来使用Fabric比较多，其实Fabric实质上还是在跑shell等命令。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://example.com/tags/Flask/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-01-23T07:46:04.068Z","updated":"2023-01-23T13:34:35.232Z","comments":true,"path":"2023/01/23/hello-world/","link":"","permalink":"http://example.com/2023/01/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"}]},{"title":"Android so文件的加解密","slug":"Android-so文件的加解密","date":"2022-12-14T14:10:02.000Z","updated":"2023-01-23T13:34:02.791Z","comments":true,"path":"2022/12/14/Android-so文件的加解密/","link":"","permalink":"http://example.com/2022/12/14/Android-so%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android so加载和dump","slug":"Android-so加载和dump","date":"2022-11-27T10:39:13.000Z","updated":"2023-01-24T12:07:35.070Z","comments":true,"path":"2022/11/27/Android-so加载和dump/","link":"","permalink":"http://example.com/2022/11/27/Android-so%E5%8A%A0%E8%BD%BD%E5%92%8Cdump/","excerpt":"","text":"加载 ELF文件介绍 ELF文件是Unix中的ABI。Linux中的执行文件基本都是ELF文件，同样Android和iOS中也如此。其主要有四种类型： 可重定位文件（Relocatable File）包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据，即 xxx.o 文件。 可执行文件（Executable File）包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像，即 a.out文件。 共享目标文件（Shared Object File）包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像，即 xxx.so文件。 内核转储(core dumps)，存放当前进程的执行上下文，用于dump信号触发。 我们可以通过readelf工具查看ELF文件的相关信息，或者使用010 editor等工具进行查看。 ELF文件通常由以下几部分组成： ELF头（ELF Header）：位于文件开始位置。用于描述文件主要特性，包括魔数、架构、程序头标偏移、节头表偏移等。 程序头表（Program Header Table）：位于ELF Header之后。列举了所有有效的段（Segment）以及他们的属性。 节头表（Section Header Table）：位于文件的末尾。列举了所有节（Section）以及他们的属性。 ELF文件加载 ELF文件有两种试图模式，“链接视图（Linkable）”和“执行视图（Executable）”，其中链接视图以节（Section）为单位，执行视图以（Segment）为单位。 举个例子，假如我们有多个可重定位文件，即xxx.o文件，这些文件内部都是section，例如.text、.rodata等。当要链接成执行文件时，各个section就会合并成segment，主要是为了执行时方便加载。 加载ELF时的系统调用函数流程如下，处理函数为load_elf_binary： load_elf_binary大致流程是： 读取并检查目标程序的ELF头 加载目标程序的Program Header Table 处理动态链接，即解释器段（Linux会使用ld-linux.so，Android是linker） 加载必须的Segment，即类型为PT_LOAD的Segment 填入程序的入口地址 设置目标函数的参数、环境变量等必要信息 调用start_thread准备执行函数 Android中so的加载 安卓中APP进程加载so文件是通过Java层函数System.loadLibrary()去加载，实际上在调用链底层还是调用了dlopen，然后用dlsym去找JNI_OnLoad的符号，找到后再执行JNI_OnLoad。查看Linker源码，dlopen返回一个soinfo结构体指针。 dump Mem dump Dump so文件即从内存中把so文件保存到本地，一般是逆向分析时遇到了so文件被静态加固了，所以尝试dump的方式意图还原后的so文件。因为一般情况下so的还原会在加载时完成，所以加载到内存之后的so大概率是还原了的。 dump的方法还是非常简单的，这里贴一个用Frida来dump的例子： 123456789101112131415161718192021222324252627function dump_so()&#123; Java.perform(function() &#123; try &#123; var libso = Process.findModuleByName(&quot;libtest.so&quot;); console.log(&quot;[dump] Find module: &quot; + libso.name); console.log(&quot;[dump] Start addr: &quot; + libso.base); console.log(&quot;[dump] So size: &quot; + libso.size); if (libso)&#123; Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;); var libso_buffer = ptr(libso.base).readByteArray(libso.size); var file_path = &quot;/data/local/tmp/&quot; + libso.name + &quot;.so&quot;; var file_handle = new File(file_path, &quot;wb&quot;); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(&quot;[dump] Finish dump: &quot;, file_path); &#125; &#125; catch (e) &#123; console.log(e); &#125; &#125;);&#125;setImmediate(dump_so); 跨进程dump process_vm_readv 处理反so dump 很多商业软件都会做内存防护，特别是游戏领域，通过内存防修改、防搜索、防dump等等，来抵制外挂。这里不以破解为目的，从学习的角度上来浅谈一下如何绕过so dump检测。 inotify检测及绕过 inotify是Linux提供的监控文件系统的变化的接口，这种变化包括文件被访问、修改、读写权限修改等等。因此，当破解者有时进行内存dump时，可能会对文件的权限进行修改（例如从不可读改成可读），这个时候就可以通过inotify进行检测。有不少商业方案就用的inotify，例如这个梆梆加固的反dump。 这种情况下通常思路是查找inotify的调用函数，然后对逻辑进行修改，例如修改返回值。 so在内存不连续 之前遇到过游戏主模块so文件在内存中是不连续的，整个so文件被拆分成多段分别分布。这种情况下的处理方法基本是将每一段都dump下来然后再做修复。 so数据修改 这种情况也是比较常见的，因为相对而言修改so数据的成本会比较低。我们通过对so的加载分析发现，在so加载时是使用的“执行视图”，因此部分section相关的字段是没用的，例如e_shoff、e_shnum等Section Header相关字段。而偏偏我们在逆向分析时，这些字段非常重要，因为IDA等反汇编工具需要Section相关信息去定位和加载各个Section，所以这些字段修改过后IDA就会加载失败。 如果我们dump下来的是有问题的，可以尝试通过dynamic段去尽可能还原一些section的信息，从而得到一个IDA可分析的so文件。","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"dump","slug":"dump","permalink":"http://example.com/tags/dump/"}]},{"title":"Android zygote注入","slug":"Android-zygote注入","date":"2022-11-19T09:22:25.000Z","updated":"2023-01-24T11:50:51.574Z","comments":true,"path":"2022/11/19/Android-zygote注入/","link":"","permalink":"http://example.com/2022/11/19/Android-zygote%E6%B3%A8%E5%85%A5/","excerpt":"","text":"zygote介绍 安卓开机流程： Zygote进程在Init进程启动过程中被以service服务的形式启动，也就是通过app_process程序启动。app_process程序代码对应的就是app_main.cpp。 Zygote的主要作用： 启动dalvik虚拟机（dalvik进程是zygote fork的） 加载系统必须的一些资源 启动framework的SystemServer进程（SystemServer进程是zygote fork的） 等待创建应用进程的请求 zygote注入流程 我们从上一节的Android应用进程共享可见，Zygote fork出的进程都继承了Zygote内存空间，因此如果我们将模块注入Zygote进程，也同样会被其fork出的进程继承。 流程基本可以参考《Android ptrace注入》，注入对象变成了zygote进程。 代码实现 使用《Android ptrace注入》的代码即可。 实验结果 zygote注入libtest： fork出的进程也载入了libtest：","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"Android ptrace注入","slug":"Android-ptrace注入","date":"2022-11-18T14:23:43.000Z","updated":"2023-01-24T11:37:47.034Z","comments":true,"path":"2022/11/18/Android-ptrace注入/","link":"","permalink":"http://example.com/2022/11/18/Android-ptrace%E6%B3%A8%E5%85%A5/","excerpt":"","text":"ptrace介绍 ptrace是Liunx系统的一个用来追踪进程的系统调用，功能是提供了一个进程可以观察、控制另一个进程的内存和寄存器。 其基本原理是，当一个进程A使用ptrace了进程B之后，发送给B的所有信号（除了SIGKILL）都会被转发给A，同时B会被堵塞，并且B的状态会被系统标识为TASK_TRACED。A收到发送给B的信号之后，可以对阻塞中的B进行检查和修改，之后再让B继续执行。 12#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); ptrace函数有四个参数： request：决定了ptrace要执行的命令； pid：为要追踪的进程id； addr：为要操作的内存地址； data：为存放读取出的或者要写入的数据。 其中request有一些常见指令： 指令 含义 PTRACE_ATTACH 附加指定的pid进程 PTRACE_DETACH 结束对指定的pid进程附加 PTRACE_GETREGS\\PTRACE_GETFPREGS 获取指定pid进程的普通\\浮点寄存器值到data中 PTRACE_SETREGS\\PTRACE_SETFPREGS 将data中的寄存器值设置到指定pid进程中 PTRACE_PEEKTEXT 将指定pid进程中地址为addr的内存数据读取一个字(word)到data中 PTRACE_POKETEXT 将data中的一个字长度的数据写入到指定pid进程中地址为addr的内存里 其他详细信息可见：https://www.tutorialspoint.com/unix_system_calls/ptrace.htm ptrace注入流程 简单来说： ptrace attach到远程进程； 获取并保存寄存器环境； 计算并获取远程进程的mmap、dlopen、dlsym等关键函数的地址； 使用ptrace写入需要的参数和内存，并修改pc寄存器的值为远程进程目标的值； 远程进程内调用dlopen动态链接要注入的so文件； 远程进程内调用dlsym执行被注入so文件的入口函数； 恢复寄存器环境； 从远程进程detach。 代码实现 https://github.com/Seventysix/android-ptrace-inject 实验结果 针对64位执行的UE4 demo游戏进行了注入，结果成功： 命令行输出： 动态调试，so成功注入： 调用libtest.so的hook_entry函数执行成功：","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"},{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://example.com/tags/Flask/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"dump","slug":"dump","permalink":"http://example.com/tags/dump/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]}