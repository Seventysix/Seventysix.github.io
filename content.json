{"meta":{"title":"Seventysix's blog","subtitle":"","description":"","author":"Seventysix","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-01-23T11:09:27.899Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-01-23T11:09:27.957Z","updated":"2023-01-23T08:35:03.120Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-01-23T11:09:27.929Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-01-24T10:15:35.380Z","updated":"2023-01-24T10:15:35.380Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系方式 邮 箱：beason76@foxmail.com 工作经历 网易（上海）网络科技有限公司 2020.7~至今 高级测试开发工程师 负责QA安全中台安全评审、工具研发、安全测试等安全相关工作； 参与过上海部分游戏项目自动化测试、CI/CD的开展； 参与过上海部分游戏项目测试工作开展的技术支持； 参与过公共工具的研发维护。 教育经历 上海大学 2018~2020 软件工程-硕士 宁波大学 2014~2018 信息管理与信息系统-本科 个人介绍 一个平平无奇的上班族罢了，喜欢看番、打游戏、研究感兴趣的技术"},{"title":"分类","date":"2023-01-23T11:09:27.943Z","updated":"2023-01-23T08:35:03.119Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-01-23T11:09:27.986Z","updated":"2023-01-23T08:35:03.120Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-01-23T11:09:27.971Z","updated":"2023-01-23T08:35:03.120Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask源码阅读之Werkzeug","slug":"Flask源码阅读之Werkzeug","date":"2023-01-30T13:10:03.000Z","updated":"2023-02-02T13:10:03.000Z","comments":true,"path":"2023/01/30/Flask源码阅读之Werkzeug/","link":"","permalink":"http://example.com/2023/01/30/Flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8BWerkzeug/","excerpt":"","text":"概述 Flask核心功能依赖于两个库：Jinja和Werkzeug。前者作为Flask的模版（Template）引擎，提供了Flask创建模版以及相关功能的支持；后者作为一个wsgi工具库，为Flask实现核心功能提供了支持。本文主要通过对Flask源码的阅读，学习下其核心功能是如何实现的，以及Werkzeug起到了一个什么作用。 Flask应用启动 Flask官方建议在生产环境中，不要使用其自带的wsgi，因为并不保证安全和性能。但我们还是从启动开始研究Werkzeug的作用。 一个简单的Flask应用可能是这样的： 12345678910from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;) def index(): return &quot;Test succeed.&quot; if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=76) 我们查看app.run内部，在其处理完参数之后，核心就是以下几句，调用werkzeug.serving模块的run_simple： 12345from werkzeug.serving import run_simple try: run_simple(t.cast(str, host), port, self, **options) finally: self._got_first_request = False 我们来看下传进去的几个参数： t.cast(str, host)：调用typing.cast(typ, val)把host转成字符串类型； port：服务占用的端口； self：即app本身，我们用Flask()创建的Application； options：可选项字典，例如是否是debug模式等等。 继续查看run_simple的内部，我们发现如果设置debug=true时，会将app转换成DebuggedApplication，并且会使用run_with_reloader运行通过make_server()函数构造的server；如果不是debug执行，则直接执行server。 1234567891011121314151617181920212223242526def run_simple(hostname, port, application, use_reloader = False, use_debugger = False, ...): ...省略部分代码... if use_debugger: from .debug import DebuggedApplication application = DebuggedApplication(application, evalex=use_evalex) ...省略部分代码... srv = make_server(hostname, port, application, threaded, processes, request_handler, passthrough_errors, ssl_context, fd=fd,) if not is_running_from_reloader(): srv.log_startup() _log(&quot;info&quot;, _ansi_style(&quot;Press CTRL+C to quit&quot;, &quot;yellow&quot;)) if use_reloader: from ._reloader import run_with_reloader run_with_reloader( srv.serve_forever, extra_files=extra_files, exclude_patterns=exclude_patterns, interval=reloader_interval, reloader_type=reloader_type, ) else: srv.serve_forever() DebuggedApplication就是将我们构造的Application封装了一层，提供了对Application进行调试的支持。当我们应用内部运行出错时会显示出一个错误页面，展示发生错误时那帧的traceback，大致如下图： 在看run_with_reloader之前，先看一下make_server函数。 123456789101112def make_server(host, port, app, threaded = False, processes = 1, request_handler = None, passthrough_errors = False, ssl_context = None, fd = None,)： if threaded and processes &gt; 1: raise ValueError(&quot;Cannot have a multi-thread and multi-process server.&quot;) if threaded: return ThreadedWSGIServer(host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd) if processes &gt; 1: return ForkingWSGIServer(host,port,app,processes,request_handler,passthrough_errors,ssl_context,fd=fd,) return BaseWSGIServer(host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd) 该函数会根据传入的参数，决定返回多进程Server、多线程Server还是基础的Server，默认会返回一个基础Server。其中ThreadedWSGIServer、ForkingWSGIServer都是BaseWSGIServer的子类，BaseWSGIServer是HTTPServer的子类。 run_with_reloader这部分会用一个线程执行srv.serve_forever()，另一个线程来启动一个ReloaderLoop对象，这个对象会按设定的interval去遍历一遍项目文件，查看当前文件是否有修改，如果有则重新reload一遍。 而srv.serve_forever()则是直接使用的HTTPServer父类BaseServer的方法serve_forever()。 Flask路由 路由添加 继续使用上一节中的简单Flask应用，我们用装饰器函数@app.route(&quot;/&quot;) 来添加了一个路由，我们查看route函数内部，发现其实际调用了Flask.add_url_rule函数来进行路由的添加： 123456def route(self, rule: str, **options: t.Any) -&gt; t.Callable[[T_route], T_route]: def decorator(f: T_route) -&gt; T_route: endpoint = options.pop(&quot;endpoint&quot;, None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator 我们继续查看Flask.add_url_rule函数： 12345678910111213141516def add_url_rule(self,rule: str,endpoint = None,view_func = None,provide_automatic_options: = None,**options: t.Any,) -&gt; None: ...省略部分代码... rule = self.url_rule_class(rule, methods=methods, **options) rule.provide_automatic_options = provide_automatic_options # type: ignore self.url_map.add(rule) if view_func is not None: old_func = self.view_functions.get(endpoint) if old_func is not None and old_func != view_func: raise AssertionError( &quot;View function mapping is overwriting an existing&quot; f&quot; endpoint function: &#123;endpoint&#125;&quot; ) self.view_functions[endpoint] = view_func 在这个函数中 先处理参数； 然后用werkzeug.routing.rules模块的Rule类创建路由rule对应的实例，并将其加入self.url_map中。self.url_map是werkzeug.routing.map模块的Map类创建的实例； 最后将这个路由对应的方法加入self.view_functions字典中，其key则为endpoint（endpoint默认为路由对应的函数名称）。 Flask自己添加路由的部分就到此为止了，后续的路由解析、匹配等重要功能还是依托于werkzeug.routing.map模块的Map类，我们先看Map内是如何添加一个路由的： 12345678class Map: def add(self, rulefactory: &quot;RuleFactory&quot;) -&gt; None: for rule in rulefactory.get_rules(self): rule.bind(self) if not rule.build_only: self._matcher.add(rule) self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule) self._remap = True 其实很简单，就是将其Rule实例加入到自己的self._rules_by_endpoint字典中，key为endpoint。 路由匹配 我们添加路由以后，当一个对应的请求过来之后，Flask内部是如何处理这个请求去找到并执行对应方法的呢？我们通过对Flask这个类的代码进行阅读，梳理出主要流程如下，我们讲讲其中的关键步骤： Flask在处理请求时，执行到Flask.wsgi_app函数时会创建请求的上下文对象，并将其压栈： 1234567891011121314151617181920212223def wsgi_app(self, environ: dict, start_response: t.Callable) -&gt; t.Any: ctx = self.request_context(environ) # 创建上下文对象 error: t.Optional[BaseException] = None try: try: ctx.push() # 压栈 response = self.full_dispatch_request() except Exception as e: error = e response = self.handle_exception(e) except: # noqa: B001 error = sys.exc_info()[1] raise return response(environ, start_response) finally: if &quot;werkzeug.debug.preserve_context&quot; in environ: environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_app.get()) environ[&quot;werkzeug.debug.preserve_context&quot;](_cv_request.get()) if error is not None and self.should_ignore_error(error): error = None ctx.pop(error) 这个RequestContext对象在初始化时会调用Flask.create_url_adapter，这个函数的主要作用是将self.url_map绑定到WSGI environment上，然后返回一个MapAdapter对象，供我们后续匹配路由。 而当RequestContext对象被push时会调用match_request，这个函数内会调用MapAdapter.match去匹配当前请求的路由。最后则会执行dispatch_request处理请求： 12345678910class Flask(Scaffold): def dispatch_request(self) -&gt; ft.ResponseReturnValue: req = request_ctx.request if req.routing_exception is not None: self.raise_routing_exception(req) rule: Rule = req.url_rule if (getattr(rule, &quot;provide_automatic_options&quot;, False) and req.method == &quot;OPTIONS&quot;): return self.make_default_options_response() view_args: t.Dict[str, t.Any] = req.view_args return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args) 其逻辑还是非常简单易懂的，获取request对象中的路由url_rule和参数view_args，通过url_rule的endpoint去self.view_functions字典中找到对应的视图函数，然后传入参数进行执行。 Flask请求和响应 还是以这个简单的Flask应用为例，来看看请求和响应： 12345678910111213141516from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route(&quot;/&quot;) def index(): if request.method == &quot;GET&quot;: return &quot;A get request.&quot; elif request.method == &quot;POST&quot;: return &quot;A post request.&quot; else: return &quot;Test succeed.&quot; if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=76) 请求 我们一般直接通过import flask.globals里的request单例来获取请求的信息，例如判断请求的类型等等： 123request: &quot;Request&quot; = LocalProxy( # type: ignore[assignment] _cv_request, &quot;request&quot;, unbound_message=_no_req_msg ) 我们查看其代码，位于flask.wrappers模块的Request类，我们发现他本身的代码很简单，主要是添加了一些蓝图、端点等内容。继续查看其父类，位于werkzeug.wrappers.request模块的Request类： 1234567891011121314151617181920212223242526class Request(_SansIORequest): def __init__( self, environ: &quot;WSGIEnvironment&quot;, populate_request: bool = True, shallow: bool = False, ) -&gt; None: super().__init__( method=environ.get(&quot;REQUEST_METHOD&quot;, &quot;GET&quot;), scheme=environ.get(&quot;wsgi.url_scheme&quot;, &quot;http&quot;), server=_get_server(environ), root_path=_wsgi_decoding_dance( environ.get(&quot;SCRIPT_NAME&quot;) or &quot;&quot;, self.charset, self.encoding_errors ), path=_wsgi_decoding_dance( environ.get(&quot;PATH_INFO&quot;) or &quot;&quot;, self.charset, self.encoding_errors ), query_string=environ.get(&quot;QUERY_STRING&quot;, &quot;&quot;).encode(&quot;latin1&quot;), headers=EnvironHeaders(environ), remote_addr=environ.get(&quot;REMOTE_ADDR&quot;), ) self.environ = environ self.shallow = shallow if populate_request and not shallow: self.environ[&quot;werkzeug.request&quot;] = self 从其初始化函数中我们可以看到，Request会从WSGIEnvironment中读取相关信息，例如REQUEST_METHOD等等。 响应 继续回到我们这一节的简单应用，假如客户端发送了一个GET类型的request，我们将返回一个“A get request.”字符串，返回的这个字符串是如何响应到客户端的呢？ 我们回到“路由匹配”那个执行图的Flask.full_dispatch_request函数： 123456789101112131415def full_dispatch_request(self) -&gt; Response: if not self._got_first_request: with self._before_request_lock: if not self._got_first_request: for func in self.before_first_request_funcs: self.ensure_sync(func)() self._got_first_request = True try: request_started.send(self) rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() except Exception as e: rv = self.handle_user_exception(e) return self.finalize_request(rv) # 最后将路由对应的视图函数执行结果进行处理 在这个函数的最后，会把视图函数执行的结果传入finalize_request函数中进行处理。我们来看下这个函数： 12345678910111213141516def finalize_request( self, rv: t.Union[ft.ResponseReturnValue, HTTPException], from_error_handler: bool = False, ) -&gt; Response: response = self.make_response(rv) try: response = self.process_response(response) request_finished.send(self, response=response) except Exception: if not from_error_handler: raise self.logger.exception( &quot;Request finalizing failed with an error while handling an error&quot; ) return response 这个函数主要功能，先通过make_response创建出Response对象，然后执行process_response来对Response对象进行处理，例如执行hook函数等。 Response类位于flask.wrappers，其代码很少，主要功能还是在父类werkzeug.wrappers.response模块的Response类中。 12345678910111213141516171819202122232425262728293031class Response(_SansIOResponse): def __init__( self, response: t.Optional[ t.Union[t.Iterable[bytes], bytes, t.Iterable[str], str] ] = None, status: t.Optional[t.Union[int, str, HTTPStatus]] = None, headers: t.Optional[ t.Union[ t.Mapping[str, t.Union[str, int, t.Iterable[t.Union[str, int]]]], t.Iterable[t.Tuple[str, t.Union[str, int]]], ] ] = None, mimetype: t.Optional[str] = None, content_type: t.Optional[str] = None, direct_passthrough: bool = False, ) -&gt; None: super().__init__( status=status, headers=headers, mimetype=mimetype, content_type=content_type, ) self.direct_passthrough = direct_passthrough self._on_close: t.List[t.Callable[[], t.Any]] = [] if response is None: self.response = [] elif isinstance(response, (str, bytes, bytearray)): self.set_data(response) else: self.response = response 其初始化时会设置返回状态码、headers、数据等等。 Flask上下文管理 我们在使用request的时候，发现有用到flask.globals模块，这里面主要有两块内容：Application Context及其全局变量、Request Context及其全局变量。Application Context是在启动app时会初始化的上下文对象，内部存放整体的信息；Request Context存放处理请求时的context，当该次请求处理完时也会销毁。 12345678910111213141516171819202122232425# Application Context 内容_cv_app: ContextVar[&quot;AppContext&quot;] = ContextVar(&quot;flask.app_ctx&quot;) __app_ctx_stack = _FakeStack(&quot;app&quot;, _cv_app) app_ctx: &quot;AppContext&quot; = LocalProxy( # type: ignore[assignment] _cv_app, unbound_message=_no_app_msg ) current_app: &quot;Flask&quot; = LocalProxy( # type: ignore[assignment] _cv_app, &quot;app&quot;, unbound_message=_no_app_msg ) g: &quot;_AppCtxGlobals&quot; = LocalProxy( # type: ignore[assignment] _cv_app, &quot;g&quot;, unbound_message=_no_app_msg )# Request Context 内容_cv_request: ContextVar[&quot;RequestContext&quot;] = ContextVar(&quot;flask.request_ctx&quot;) __request_ctx_stack = _FakeStack(&quot;request&quot;, _cv_request) request_ctx: &quot;RequestContext&quot; = LocalProxy( # type: ignore[assignment] _cv_request, unbound_message=_no_req_msg ) request: &quot;Request&quot; = LocalProxy( # type: ignore[assignment] _cv_request, &quot;request&quot;, unbound_message=_no_req_msg ) session: &quot;SessionMixin&quot; = LocalProxy( # type: ignore[assignment] _cv_request, &quot;session&quot;, unbound_message=_no_req_msg ) 我们知道全局变量是不可改变的，因此Flask用到了werkzeug.local模块来实现这种类似全局变量的东西，同时兼顾了多线程。我们先来看下local模块的基础类Local： 123456789101112131415161718192021222324252627282930class Local: __slots__ = (&quot;__storage&quot;,) def __init__( self, context_var: t.Optional[ContextVar[t.Dict[str, t.Any]]] = None ) -&gt; None: if context_var is None: context_var = ContextVar(f&quot;werkzeug.Local&lt;&#123;id(self)&#125;&gt;.storage&quot;) object.__setattr__(self, &quot;_Local__storage&quot;, context_var) def __call__( self, name: str, *, unbound_message: t.Optional[str] = None ) -&gt; &quot;LocalProxy&quot;: return LocalProxy(self, name, unbound_message=unbound_message) def __release_local__(self) -&gt; None: self.__storage.set(&#123;&#125;) def __getattr__(self, name: str) -&gt; t.Any: values = self.__storage.get(&#123;&#125;) if name in values: return values[name] raise AttributeError(name) def __setattr__(self, name: str, value: t.Any) -&gt; None: values = self.__storage.get(&#123;&#125;).copy() values[name] = value self.__storage.set(values) Local通过self.__storage来存储数据，其本身是一个dict。context_var则根据类型可以传入AppContext或者RequestContext。线程安全主要通过LocalProxy来实现。 LocalStack类其实也类似，是一个线程安全的栈对象，也是通过LocalProxy来实现线程安全。 LocalProxy类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LocalProxy(t.Generic[T]): __slots__ = (&quot;__wrapped&quot;, &quot;_get_current_object&quot;) _get_current_object: t.Callable[[], T] def __init__( self, local: t.Union[ContextVar[T], Local, LocalStack[T], t.Callable[[], T]], name: t.Optional[str] = None, *, unbound_message: t.Optional[str] = None, ) -&gt; None: if name is None: get_name = _identity else: get_name = attrgetter(name) # type: ignore[assignment] if unbound_message is None: unbound_message = &quot;object is not bound&quot; if isinstance(local, Local): if name is None: raise TypeError(&quot;&#x27;name&#x27; is required when proxying a &#x27;Local&#x27; object.&quot;) def _get_current_object() -&gt; T: try: return get_name(local) # type: ignore[return-value] except AttributeError: raise RuntimeError(unbound_message) from None elif isinstance(local, LocalStack): def _get_current_object() -&gt; T: obj = local.top # type: ignore[union-attr] if obj is None: raise RuntimeError(unbound_message) return get_name(obj) elif isinstance(local, ContextVar): def _get_current_object() -&gt; T: try: obj = local.get() # type: ignore[union-attr] except LookupError: raise RuntimeError(unbound_message) from None return get_name(obj) elif callable(local): def _get_current_object() -&gt; T: return get_name(local()) # type: ignore else: raise TypeError(f&quot;Don&#x27;t know how to proxy &#x27;&#123;type(local)&#125;&#x27;.&quot;) object.__setattr__(self, &quot;_LocalProxy__wrapped&quot;, local) object.__setattr__(self, &quot;_get_current_object&quot;, _get_current_object) __wrapped__ = _ProxyLookup( fallback=lambda self: self._LocalProxy__wrapped, is_attr=True ) LocalProxy主要起到获取当前Local对象，然后将对自己的操作转发给这个Local对象。","categories":[],"tags":[]},{"title":"Flask建站自用标配","slug":"Flask建站自用标配","date":"2023-01-25T06:54:31.000Z","updated":"2023-01-25T06:54:31.000Z","comments":true,"path":"2023/01/25/Flask建站自用标配/","link":"","permalink":"http://example.com/2023/01/25/Flask%E5%BB%BA%E7%AB%99%E8%87%AA%E7%94%A8%E6%A0%87%E9%85%8D/","excerpt":"","text":"简介 一套自己在部署Python开发的后端服务时常用的架构，简单做个记录。 一图流 入口 请求直接打到nginx。虽说直接用nginx作为入口，一旦nginx挂了整个服务就挂了。但由于目前参与部署的服务大多是公司、部门内部使用的服务，或者是自己搭着玩的web站点，机器资源有限（一般就只有一台），因此单点挂了就挂了。 如果是有个集群的情况下，可以通过Keepalived来应对nginx单点故障的问题。 在我目前的场景中，nginx主要起到： 处理静态请求展示前端页面； 内部域名映射； 多个服务的统一入口管理。 应用服务器 Flask、Django开发的应用直接用命令行跑起来，其他人当然也是可以调用的。但假如你这个服务使用的人多了起来，Flask等自带的wsgi性能就不那么好了。uWSGI、Gunicorn这类wsgi server可以提供更好的并发性能支持。 《WSGI 服务器性能分析》中对比了比较出名的几款wsgi工具的性能，这里我常用的是Gunicorn。 Web框架 个人更喜欢Flask，相对Django而言更精简。不过这部分用什么框架还是看实际场景和需求，还有开发人员的熟练程度吧。 监控管理 一方面Gunicorn重启关闭麻烦，另一方面我们又希望如果服务进程因为内部错误等原因挂了，还能够自己重新启动，不妨碍继续使用。因此supervisor的引入是非常有必要的。 supervisor可以起到以下几个作用： 简单配置之后可以非常方便的进行Gunicorn进程的启动、重启、关闭； 可以查看Gunicorn的执行状态； 可以配置挂掉的进程自动重启。 CI/CD 这部分其实就是自动更新部署的内容，最开始的时候是直接写个shell脚本去进行服务端项目的更新、重启，后来使用Fabric比较多，其实Fabric实质上还是在跑shell等命令。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://example.com/tags/Flask/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-01-23T07:46:04.068Z","updated":"2023-01-23T13:34:35.232Z","comments":true,"path":"2023/01/23/hello-world/","link":"","permalink":"http://example.com/2023/01/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"}]},{"title":"Android so文件的加解密","slug":"Android-so文件的加解密","date":"2022-12-14T14:10:02.000Z","updated":"2023-01-23T13:34:02.791Z","comments":true,"path":"2022/12/14/Android-so文件的加解密/","link":"","permalink":"http://example.com/2022/12/14/Android-so%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android so加载和dump","slug":"Android-so加载和dump","date":"2022-11-27T10:39:13.000Z","updated":"2023-01-24T12:07:35.070Z","comments":true,"path":"2022/11/27/Android-so加载和dump/","link":"","permalink":"http://example.com/2022/11/27/Android-so%E5%8A%A0%E8%BD%BD%E5%92%8Cdump/","excerpt":"","text":"加载 ELF文件介绍 ELF文件是Unix中的ABI。Linux中的执行文件基本都是ELF文件，同样Android和iOS中也如此。其主要有四种类型： 可重定位文件（Relocatable File）包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据，即 xxx.o 文件。 可执行文件（Executable File）包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像，即 a.out文件。 共享目标文件（Shared Object File）包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像，即 xxx.so文件。 内核转储(core dumps)，存放当前进程的执行上下文，用于dump信号触发。 我们可以通过readelf工具查看ELF文件的相关信息，或者使用010 editor等工具进行查看。 ELF文件通常由以下几部分组成： ELF头（ELF Header）：位于文件开始位置。用于描述文件主要特性，包括魔数、架构、程序头标偏移、节头表偏移等。 程序头表（Program Header Table）：位于ELF Header之后。列举了所有有效的段（Segment）以及他们的属性。 节头表（Section Header Table）：位于文件的末尾。列举了所有节（Section）以及他们的属性。 ELF文件加载 ELF文件有两种试图模式，“链接视图（Linkable）”和“执行视图（Executable）”，其中链接视图以节（Section）为单位，执行视图以（Segment）为单位。 举个例子，假如我们有多个可重定位文件，即xxx.o文件，这些文件内部都是section，例如.text、.rodata等。当要链接成执行文件时，各个section就会合并成segment，主要是为了执行时方便加载。 加载ELF时的系统调用函数流程如下，处理函数为load_elf_binary： load_elf_binary大致流程是： 读取并检查目标程序的ELF头 加载目标程序的Program Header Table 处理动态链接，即解释器段（Linux会使用ld-linux.so，Android是linker） 加载必须的Segment，即类型为PT_LOAD的Segment 填入程序的入口地址 设置目标函数的参数、环境变量等必要信息 调用start_thread准备执行函数 Android中so的加载 安卓中APP进程加载so文件是通过Java层函数System.loadLibrary()去加载，实际上在调用链底层还是调用了dlopen，然后用dlsym去找JNI_OnLoad的符号，找到后再执行JNI_OnLoad。查看Linker源码，dlopen返回一个soinfo结构体指针。 dump Mem dump Dump so文件即从内存中把so文件保存到本地，一般是逆向分析时遇到了so文件被静态加固了，所以尝试dump的方式意图还原后的so文件。因为一般情况下so的还原会在加载时完成，所以加载到内存之后的so大概率是还原了的。 dump的方法还是非常简单的，这里贴一个用Frida来dump的例子： 123456789101112131415161718192021222324252627function dump_so()&#123; Java.perform(function() &#123; try &#123; var libso = Process.findModuleByName(&quot;libtest.so&quot;); console.log(&quot;[dump] Find module: &quot; + libso.name); console.log(&quot;[dump] Start addr: &quot; + libso.base); console.log(&quot;[dump] So size: &quot; + libso.size); if (libso)&#123; Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;); var libso_buffer = ptr(libso.base).readByteArray(libso.size); var file_path = &quot;/data/local/tmp/&quot; + libso.name + &quot;.so&quot;; var file_handle = new File(file_path, &quot;wb&quot;); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(&quot;[dump] Finish dump: &quot;, file_path); &#125; &#125; catch (e) &#123; console.log(e); &#125; &#125;);&#125;setImmediate(dump_so); 跨进程dump process_vm_readv 处理反so dump 很多商业软件都会做内存防护，特别是游戏领域，通过内存防修改、防搜索、防dump等等，来抵制外挂。这里不以破解为目的，从学习的角度上来浅谈一下如何绕过so dump检测。 inotify检测及绕过 inotify是Linux提供的监控文件系统的变化的接口，这种变化包括文件被访问、修改、读写权限修改等等。因此，当破解者有时进行内存dump时，可能会对文件的权限进行修改（例如从不可读改成可读），这个时候就可以通过inotify进行检测。有不少商业方案就用的inotify，例如这个梆梆加固的反dump。 这种情况下通常思路是查找inotify的调用函数，然后对逻辑进行修改，例如修改返回值。 so在内存不连续 之前遇到过游戏主模块so文件在内存中是不连续的，整个so文件被拆分成多段分别分布。这种情况下的处理方法基本是将每一段都dump下来然后再做修复。 so数据修改 这种情况也是比较常见的，因为相对而言修改so数据的成本会比较低。我们通过对so的加载分析发现，在so加载时是使用的“执行视图”，因此部分section相关的字段是没用的，例如e_shoff、e_shnum等Section Header相关字段。而偏偏我们在逆向分析时，这些字段非常重要，因为IDA等反汇编工具需要Section相关信息去定位和加载各个Section，所以这些字段修改过后IDA就会加载失败。 如果我们dump下来的是有问题的，可以尝试通过dynamic段去尽可能还原一些section的信息，从而得到一个IDA可分析的so文件。","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"dump","slug":"dump","permalink":"http://example.com/tags/dump/"}]},{"title":"Android zygote注入","slug":"Android-zygote注入","date":"2022-11-19T09:22:25.000Z","updated":"2023-01-24T11:50:51.574Z","comments":true,"path":"2022/11/19/Android-zygote注入/","link":"","permalink":"http://example.com/2022/11/19/Android-zygote%E6%B3%A8%E5%85%A5/","excerpt":"","text":"zygote介绍 安卓开机流程： Zygote进程在Init进程启动过程中被以service服务的形式启动，也就是通过app_process程序启动。app_process程序代码对应的就是app_main.cpp。 Zygote的主要作用： 启动dalvik虚拟机（dalvik进程是zygote fork的） 加载系统必须的一些资源 启动framework的SystemServer进程（SystemServer进程是zygote fork的） 等待创建应用进程的请求 zygote注入流程 我们从上一节的Android应用进程共享可见，Zygote fork出的进程都继承了Zygote内存空间，因此如果我们将模块注入Zygote进程，也同样会被其fork出的进程继承。 流程基本可以参考《Android ptrace注入》，注入对象变成了zygote进程。 代码实现 使用《Android ptrace注入》的代码即可。 实验结果 zygote注入libtest： fork出的进程也载入了libtest：","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"Android ptrace注入","slug":"Android-ptrace注入","date":"2022-11-18T14:23:43.000Z","updated":"2023-01-24T11:37:47.034Z","comments":true,"path":"2022/11/18/Android-ptrace注入/","link":"","permalink":"http://example.com/2022/11/18/Android-ptrace%E6%B3%A8%E5%85%A5/","excerpt":"","text":"ptrace介绍 ptrace是Liunx系统的一个用来追踪进程的系统调用，功能是提供了一个进程可以观察、控制另一个进程的内存和寄存器。 其基本原理是，当一个进程A使用ptrace了进程B之后，发送给B的所有信号（除了SIGKILL）都会被转发给A，同时B会被堵塞，并且B的状态会被系统标识为TASK_TRACED。A收到发送给B的信号之后，可以对阻塞中的B进行检查和修改，之后再让B继续执行。 12#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); ptrace函数有四个参数： request：决定了ptrace要执行的命令； pid：为要追踪的进程id； addr：为要操作的内存地址； data：为存放读取出的或者要写入的数据。 其中request有一些常见指令： 指令 含义 PTRACE_ATTACH 附加指定的pid进程 PTRACE_DETACH 结束对指定的pid进程附加 PTRACE_GETREGS\\PTRACE_GETFPREGS 获取指定pid进程的普通\\浮点寄存器值到data中 PTRACE_SETREGS\\PTRACE_SETFPREGS 将data中的寄存器值设置到指定pid进程中 PTRACE_PEEKTEXT 将指定pid进程中地址为addr的内存数据读取一个字(word)到data中 PTRACE_POKETEXT 将data中的一个字长度的数据写入到指定pid进程中地址为addr的内存里 其他详细信息可见：https://www.tutorialspoint.com/unix_system_calls/ptrace.htm ptrace注入流程 简单来说： ptrace attach到远程进程； 获取并保存寄存器环境； 计算并获取远程进程的mmap、dlopen、dlsym等关键函数的地址； 使用ptrace写入需要的参数和内存，并修改pc寄存器的值为远程进程目标的值； 远程进程内调用dlopen动态链接要注入的so文件； 远程进程内调用dlsym执行被注入so文件的入口函数； 恢复寄存器环境； 从远程进程detach。 代码实现 https://github.com/Seventysix/android-ptrace-inject 实验结果 针对64位执行的UE4 demo游戏进行了注入，结果成功： 命令行输出： 动态调试，so成功注入： 调用libtest.so的hook_entry函数执行成功：","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"},{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://example.com/tags/Flask/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"dump","slug":"dump","permalink":"http://example.com/tags/dump/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]}